# -*- coding: utf-8 -*-
"""traffic-detection-using-yolov5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1udTu7BXBERcKcMrq2cJhHLFvaQZFOELJ
"""

!git clone https://github.com/ultralytics/yolov5.git
!pip install -r yolov5/requirements.txt

import os
import shutil
import yaml
from pathlib import Path
import cv2
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import torch
import random
import numpy as np
from yolov5.models.yolo import Model
from PIL import Image as PILImage
import sys
from IPython.display import Image, display, clear_output
from matplotlib.patches import Rectangle

train_images_path = '/kaggle/input/traffic-vehicles-object-detection/Traffic Dataset/images/train'
val_images_path = '/kaggle/input/traffic-vehicles-object-detection/Traffic Dataset/images/val'
test_images_path = '/kaggle/input/traffic-vehicles-object-detection/Traffic Dataset/images/test'
train_labels_path = '/kaggle/input/traffic-vehicles-object-detection/Traffic Dataset/labels/train'
val_labels_path = '/kaggle/input/traffic-vehicles-object-detection/Traffic Dataset/labels/val'

yolo_train_images_path = '/kaggle/working/yolo_data/images/train'
yolo_val_images_path = '/kaggle/working/yolo_data/images/val'
yolo_test_images_path = '/kaggle/working/yolo_data/images/test'
yolo_train_labels_path = '/kaggle/working/yolo_data/labels/train'
yolo_val_labels_path = '/kaggle/working/yolo_data/labels/val'

def ensure_dir(directory):
    if not os.path.exists(directory):
        os.makedirs(directory)

ensure_dir(yolo_train_images_path)
ensure_dir(yolo_val_images_path)
ensure_dir(yolo_test_images_path)
ensure_dir(yolo_train_labels_path)
ensure_dir(yolo_val_labels_path)


def copy_images_and_labels(image_names, src_img_dir, src_label_dir, dest_img_dir, dest_label_dir, copy_labels=True):
    for img_name in image_names:
        src_img = os.path.join(src_img_dir, img_name)
        dest_img = os.path.join(dest_img_dir, img_name)
        if os.path.isfile(src_img):
            shutil.copy(src_img, dest_img)
        else:
            print(f"Warning: Image {src_img} not found.")
        if copy_labels:
            label_name = os.path.splitext(img_name)[0] + '.txt'
            src_label = os.path.join(src_label_dir, label_name)
            dest_label = os.path.join(dest_label_dir, label_name)
            if os.path.isfile(src_label):
                shutil.copy(src_label, dest_label)
            else:
                print(f"Warning: Label {src_label} not found.")

train_images = os.listdir(train_images_path)
val_images = os.listdir(val_images_path)
test_images = os.listdir(test_images_path)

copy_images_and_labels(train_images, train_images_path, train_labels_path, yolo_train_images_path, yolo_train_labels_path)
copy_images_and_labels(val_images, val_images_path, val_labels_path, yolo_val_images_path, yolo_val_labels_path)
copy_images_and_labels(test_images, test_images_path, None, yolo_test_images_path, None, copy_labels=False)

yolo_data_path = '/kaggle/working/yolo_data'
data_yaml_path = os.path.join(yolo_data_path, 'data.yaml')

data = {
    'train': os.path.join(yolo_data_path, 'images/train'),
    'val': os.path.join(yolo_data_path, 'images/val'),
    'test': os.path.join(yolo_data_path, 'images/test'),
    'nc': 7,
    'names': ['Car', 'Number Plate', 'Blur Number Plate', 'Two Wheeler', 'Auto', 'Bus', 'Truck']
}

with open(data_yaml_path, 'w') as f:
    yaml.dump(data, f)

print(f"Created data.yaml at {data_yaml_path}")

!ls /kaggle/working

!export WANDB_MODE=disabled && cd yolov5 && python train.py --img-size 640 --batch-size 16 --epochs 100 --data {data_yaml_path} --cfg yolov5s.yaml --weights '' --name yolov5_traffic_detection --cache

!cd yolov5 && python detect.py --weights /kaggle/working/yolov5/runs/train/yolov5_traffic_detection/weights/best.pt --img-size 640 --conf-thres 0.4 --source {os.path.join(yolo_data_path, 'images/test')} --save-txt --save-crop

def display_predictions(image_path, label_dir, class_names):
    img = cv2.imread(image_path)
    if img is None:
        print(f"Error: Unable to open image file {image_path}.")
        return
    img_height, img_width = img.shape[:2]
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    fig, ax = plt.subplots(1, figsize=(12, 9))
    ax.imshow(img_rgb)

    label_file = os.path.join(label_dir, os.path.splitext(os.path.basename(image_path))[0] + '.txt')
    if os.path.isfile(label_file):
        with open(label_file, 'r') as file:
            for line in file:
                parts = line.strip().split()
                if len(parts) < 5:
                    print(f"Warning: Incorrect format in label file {label_file}.")
                    continue
                class_id, x_center, y_center, width, height = map(float, parts)
                x_center *= img_width
                y_center *= img_height
                width *= img_width
                height *= img_height
                x_min = x_center - width / 2
                y_min = y_center - height / 2

                rect = patches.Rectangle(
                    (x_min, y_min),
                    width,
                    height,
                    linewidth=1,
                    edgecolor='r',
                    facecolor='none'
                )
                ax.add_patch(rect)
                class_name = class_names[int(class_id)]
                probability = 1.0
                ax.text(x_min, y_min, f'{class_name} ({probability:.2f})', color='white', fontsize=12, bbox=dict(facecolor='red', alpha=0.5))
    else:
        print(f"Warning: No label file found for {image_path}. Displaying image without labels.")

    ax.set_title(os.path.basename(image_path))
    ax.axis('off')
    plt.close(fig)
    display(fig)

test_img_path = '/kaggle/working/yolo_data/images/test'
label_path = '/kaggle/working/yolov5/runs/detect/exp/labels'
class_names = ['Car', 'Number Plate', 'Blur Number Plate', 'Two Wheeler', 'Auto', 'Bus', 'Truck']
test_images = [f for f in os.listdir(test_img_path) if f.lower().endswith(('.jpg', '.png'))]
random_images = random.sample(test_images, min(15, len(test_images)))
for file_name in random_images:
    image_path = os.path.join(test_img_path, file_name)
    display_predictions(image_path, label_path, class_names)

def draw_boxes_on_frame(frame, boxes, class_names):
    img_height, img_width = frame.shape[:2]
    img_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    fig, ax = plt.subplots(1, figsize=(12, 9))
    ax.imshow(img_rgb)
    for box in boxes:
        if len(box) == 5:
            class_id, x_center, y_center, width, height = box
            prob = 1.0
        elif len(box) == 6:
            class_id, x_center, y_center, width, height, prob = box
        else:
            print("Warning: Invalid box format. Skipping box.")
            continue
        x_center *= img_width
        y_center *= img_height
        width *= img_width
        height *= img_height
        x_min = x_center - width / 2
        y_min = y_center - height / 2
        rect = patches.Rectangle(
            (x_min, y_min),
            width,
            height,
            linewidth=1,
            edgecolor='r',
            facecolor='none'
        )
        ax.add_patch(rect)
        class_name = class_names[int(class_id)]
        ax.text(x_min, y_min, f'{class_name} ({prob:.2f})', color='white', fontsize=12, bbox=dict(facecolor='red', alpha=0.5))
    ax.axis('off')
    plt.close(fig)
    display(fig)

def process_video(video_path, label_dir, class_names):
    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        print(f"Error: Unable to open video file {video_path}.")
        return

    while True:
        ret, frame = cap.read()
        if not ret:
            break
        frame_number = int(cap.get(cv2.CAP_PROP_POS_FRAMES)) - 1
        base_name = os.path.basename(video_path)
        video_name = os.path.splitext(base_name)[0]
        label_file = os.path.join(label_dir, f'{video_name}_{frame_number}.txt')
        if os.path.isfile(label_file):
            with open(label_file, 'r') as file:
                boxes = [list(map(float, line.strip().split())) for line in file]
        else:
            boxes = []
        draw_boxes_on_frame(frame, boxes, class_names)
        clear_output(wait=True)
    cap.release()

def display_random_video(test_video_path, label_path, class_names):
    video_files = [f for f in os.listdir(test_video_path) if f.lower().endswith(('.mp4', '.avi', '.mov'))]
    random_video = random.choice(video_files)
    video_path = os.path.join(test_video_path, random_video)
    process_video(video_path, label_path, class_names)

test_video_path = '/kaggle/working/yolo_data/images/test'
label_path = '/kaggle/working/yolov5/runs/detect/exp/labels'
class_names = ['Car', 'Number Plate', 'Blur Number Plate', 'Two Wheeler', 'Auto', 'Bus', 'Truck']

display_random_video(test_video_path, label_path, class_names)

test_video_path = '/kaggle/working/yolo_data/images/test'
label_path = '/kaggle/working/yolov5/runs/detect/exp/labels'
class_names = ['Car', 'Number Plate', 'Blur Number Plate', 'Two Wheeler', 'Auto', 'Bus', 'Truck']

display_random_video(test_video_path, label_path, class_names)

!python yolov5/export.py --weights /kaggle/working/yolov5/runs/train/yolov5_traffic_detection/weights/best.pt --img-size 640 --batch-size 1 --device cpu --include onnx

model_path = '/kaggle/working/yolov5/runs/train/yolov5_traffic_detection/weights/best.pt'
model = torch.hub.load('/kaggle/working/yolov5', 'custom', path=model_path, source='local')
model.eval()

test_images_dir = '/kaggle/input/testing-traffic'

def predict_images(model, image_dir):
    image_paths = list(Path(image_dir).glob('*.*'))
    results = []
    for image_path in image_paths:
        img = cv2.imread(str(image_path))
        if img is None:
            print(f"Skipping file (not an image or corrupted): {image_path}")
            continue
        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        results.append((image_path, model(img_rgb)))
    return results

results = predict_images(model, test_images_dir)

for img_path, result in results:
    pred_df = result.pandas().xyxy[0]
    print(f"Processing: {img_path.name}")
    print(f"Predictions for {img_path.name}:")
    print(pred_df)
    print("\n")

def draw_boxes_for_outside_samples(img, pred, image_name, max_size=(1024, 768)):
    height, width = img.shape[:2]
    scale = min(max_size[0] / width, max_size[1] / height)
    new_width = int(width * scale)
    new_height = int(height * scale)
    resized_img = cv2.resize(img, (new_width, new_height))
    img_rgb = cv2.cvtColor(resized_img, cv2.COLOR_BGR2RGB)
    fig, ax = plt.subplots(1, figsize=(12, 9))
    ax.imshow(img_rgb)
    pred_df = pred.pandas().xyxy[0]
    if not pred_df.empty:
        for _, row in pred_df.iterrows():
            x_min = int(row["xmin"] * scale)
            y_min = int(row["ymin"] * scale)
            x_max = int(row["xmax"] * scale)
            y_max = int(row["ymax"] * scale)
            class_name = row["name"]
            confidence = row["confidence"]
            rect = patches.Rectangle(
                (x_min, y_min),
                x_max - x_min,
                y_max - y_min,
                linewidth=2,
                edgecolor='r',
                facecolor='none'
            )
            ax.add_patch(rect)
            label = f'{class_name} {confidence:.2f}'
            plt.text(x_min, y_min - 10, label, color='r', fontsize=10, weight='bold')
    ax.set_title(f'Predictions for {image_name}')
    ax.axis('off')
    plt.close(fig)
    display(fig)

for img_path, result in results:
    img = cv2.imread(str(img_path))
    if img is not None:
        image_name = img_path.name
        draw_boxes_for_outside_samples(img, result, image_name)